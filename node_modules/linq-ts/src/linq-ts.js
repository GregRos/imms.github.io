/// <reference path="../typings/linq-ts.d.ts" />
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) ENikS.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0  ( the  "License" );  you may 
// not use this file except in compliance with the License.  You may  obtain  a 
// copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required  by  applicable  law  or  agreed  to  in  writing,  software 
// distributed under the License is distributed on an "AS  IS"  BASIS,  WITHOUT
// WARRANTIES OR CONDITIONS  OF  ANY  KIND, either express or implied.  See the 
// License for the specific  language  governing  permissions  and  limitations 
// under the License.
"use strict";
require("es6-shim");
//-----------------------------------------------------------------------------
//  Functions to convert any iterable into LINQ enumerable
//-----------------------------------------------------------------------------
/**
* Converts any Iterable<T> object into LINQ-able object
* @param TSource An Array, Map, Set, String or other Iterable object.
* @example
*     import {asEnumerable} from "linq-ts";
*
*     var enumerable = asEnumerable([0, 1, 2, 3, 4, 5, 6, 7]).Take(3);
*     var sum = enumerable.Sum();
*
*/
function asEnumerable(TSource = null) {
    return new Linq(TSource);
}
exports.asEnumerable = asEnumerable;
/**
* Generates <count> of <T> elements starting with <start>. T is any
* type which could be cast to number: number, enum, etc.
* @param start First value in sequence.
* @param count Number of elements to iteratel.
* @example
*     var sum = Range(0, 7).Sum();
*/
function Range(start, count) {
    return new Linq(null, () => new GeneratorIterator(start, count, true));
}
exports.Range = Range;
/**
* Repeat element <start> of type T <count> of times.
* @param start First value in sequence.
* @param count Number of elements to iteratel.
* @example
*     var sum = Repeat("v", 7);
*/
function Repeat(start, count) {
    return new Linq(null, () => new GeneratorIterator(start, count));
}
exports.Repeat = Repeat;
//-----------------------------------------------------------------------------
//  LINQ Implementation
//-----------------------------------------------------------------------------
class Linq {
    ///////////////////////////////////////////////////////////////////////////
    constructor(target, factory, arg) {
        this._target = target;
        this._factory = factory;
        this._factoryArg = arg;
    }
    ///////////////////////////////////////////////////////////////////////////
    /** Returns JavaScript iterator */
    [Symbol.iterator]() {
        return (null != this._factory) ? this._factory(this._factoryArg)
            : (null != this._target) ? this._target[Symbol.iterator]()
                : { next: () => { return { done: true, value: undefined }; } };
    }
    /** Returns C# style enumerator */
    GetEnumerator() {
        return new Enumerator(this[Symbol.iterator]());
    }
    //-------------------------------------------------------------------------
    //  Immediate execution methods                                                                                            
    //-------------------------------------------------------------------------
    Aggregate(seed, func, resultSelector = selfFn) {
        var result = seed;
        var res, iterator = this[Symbol.iterator]();
        while (!(res = iterator.next()).done) {
            result = func(result, res.value);
        }
        return resultSelector(result);
    }
    All(predicate = trueFn) {
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (!predicate(result.value)) {
                return false;
            }
        }
        return true;
    }
    Any(predicate) {
        var result, iterator = this[Symbol.iterator]();
        // Check if at least one exist
        if (null == predicate) {
            return !iterator.next().done;
        }
        // Check if any satisfy the criteria
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                return true;
            }
        }
        return false;
    }
    Average(func = selfFn) {
        var result, sum = 0, count = 0;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            sum += result.value;
            count++;
        }
        return sum / count;
    }
    Contains(value, equal = (a, b) => a === b) {
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (equal(value, result.value)) {
                return true;
            }
        }
        return false;
    }
    Count(predicate = trueFn) {
        var result, count = 0;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                count++;
            }
        }
        return count;
    }
    Max(transform = selfFn) {
        var result, value, max, hasValue = false;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            value = transform(result.value);
            if (hasValue) {
                if (max < value)
                    max = value;
            }
            else {
                max = value;
                hasValue = true;
            }
        }
        if (!hasValue)
            throw noElements;
        return max;
    }
    Min(transform = selfFn) {
        var result, value, min, hasValue = false;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            value = transform(result.value);
            if (hasValue) {
                if (min > value)
                    min = value;
            }
            else {
                min = value;
                hasValue = true;
            }
        }
        if (!hasValue)
            throw noElements;
        return min;
    }
    ElementAt(index) {
        var result, count = 0;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (index === count++) {
                return result.value;
            }
        }
        throw "Argument Out Of Range";
    }
    ElementAtOrDefault(index) {
        var result, value, count = 0;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (index === count++) {
                return result.value;
            }
            value = result.value;
        }
        return getDefaultVal(typeof value); // Last good value
    }
    First(predicate = trueFn) {
        var result;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                return result.value;
            }
        }
        throw nothingFound;
    }
    FirstOrDefault(predicate = trueFn) {
        var result, value;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            value = result.value;
            if (predicate(value)) {
                return result.value;
            }
        }
        return getDefaultVal(typeof value); // Last good value
    }
    Last(predicate = trueFn) {
        var result, value, found = false;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                value = result.value;
                found = true;
            }
        }
        if (!found) {
            throw nothingFound;
        }
        return value;
    }
    LastOrDefault(predicate = trueFn) {
        var result, value, lastKnown, found = false;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                value = result.value;
                found = true;
            }
            lastKnown = result.value;
        }
        return (found) ? value : getDefaultVal(typeof lastKnown);
    }
    SequenceEqual(other, equal = (a, b) => a === b) {
        var res1, res2;
        var it1 = this[Symbol.iterator]();
        var it2 = other[Symbol.iterator]();
        do {
            res1 = it1.next();
            res2 = it2.next();
            if ((res1.done != res2.done) || !equal(res1.value, res2.value)) {
                return false;
            }
        } while (!(res1.done) && !(res2.done));
        return true;
    }
    Single(predicate = trueFn) {
        var value, hasValue = false;
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                if (!hasValue) {
                    value = result.value;
                    hasValue = true;
                }
                else {
                    throw tooMany;
                }
            }
        }
        if (hasValue)
            return value;
        throw nothingFound;
    }
    SingleOrDefault(predicate = trueFn) {
        var value, lastKnown, hasValue = false;
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            if (predicate(result.value)) {
                if (!hasValue) {
                    value = result.value;
                    hasValue = true;
                }
                else {
                    throw tooMany;
                }
            }
            lastKnown = result.value;
        }
        return (hasValue) ? value : getDefaultVal(typeof lastKnown);
    }
    Sum(transform = selfFn) {
        var result, sum = 0;
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            sum += result.value;
        }
        return sum;
    }
    ToArray() {
        var result, array = [];
        var iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            array.push(result.value);
        }
        return array;
    }
    ToMap(keySelector, elementSelector = selfFn) {
        var dictionary = new Map();
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            dictionary.set(keySelector(result.value), elementSelector(result.value));
        }
        return dictionary;
    }
    ToDictionary(keySelector, elementSelector = selfFn) {
        var dictionary = new Map();
        var result, iterator = this[Symbol.iterator]();
        while (!(result = iterator.next()).done) {
            dictionary.set(keySelector(result.value), elementSelector(result.value));
        }
        return dictionary;
    }
    //-------------------------------------------------------------------------
    //  Deferred execution methods
    //-------------------------------------------------------------------------
    DefaultIfEmpty(defaultValue = undefined) {
        return new Linq(this, () => new DefaultIfEmptyIteratror(this._target[Symbol.iterator](), defaultValue));
    }
    Cast() {
        return new Linq(this, () => new SelectIteratror(this._target[Symbol.iterator](), (a) => a));
    }
    Concat(second) {
        var aggregate = [this._target, second];
        return new Linq(this, () => new SelectManyIteratror(aggregate[Symbol.iterator](), selfFn, selfFn));
    }
    Distinct() {
        return new Linq(this, () => new DistinctIteratror(this._target[Symbol.iterator]()));
    }
    Except(other) {
        var _set = new Set();
        var result, otherIterator = other[Symbol.iterator]();
        while (!(result = otherIterator.next()).done) {
            _set.add(result.value);
        }
        return new Linq(this, () => new IntersectIteratror(this._target[Symbol.iterator](), _set, true));
    }
    GroupBy(selKey, selElement, selResult = defGrouping) {
        var result;
        var iterator = this[Symbol.iterator]();
        var _map = new Map();
        while (!(result = iterator.next()).done) {
            var key = selKey(result.value);
            var group = _map.get(key);
            if ('undefined' === typeof group) {
                group = [];
                _map.set(key, group);
            }
            group.push(selElement(result.value));
        }
        var factory = () => new GroupByIteratror(_map.keys(), selResult, _map);
        var tst = factory();
        return new Linq(this, () => new GroupByIteratror(_map.keys(), selResult, _map));
    }
    GroupJoin(inner, oKeySelect, iKeySelect, resultSelector = defGrouping) {
        var _map = new Map();
        var _inner = inner[Symbol.iterator]();
        var result;
        while (!(result = _inner.next()).done) {
            var key = iKeySelect(result.value);
            if ('undefined' === typeof key)
                throw "Inner Key selector returned undefined Key";
            var group = _map.get(key);
            if ('undefined' === typeof group) {
                group = [];
                _map.set(key, group);
            }
            group.push(result.value);
        }
        return new Linq(this, () => new GroupJoinIteratror(this._target[Symbol.iterator](), oKeySelect, resultSelector, _map));
    }
    Intersect(other) {
        var _set = new Set();
        var result, otherIterator = other[Symbol.iterator]();
        while (!(result = otherIterator.next()).done) {
            _set.add(result.value);
        }
        return new Linq(this, () => new IntersectIteratror(this._target[Symbol.iterator](), _set));
    }
    Join(inner, oSelector, iSelector, transform) {
        return new Linq(this, () => new JoinIteratror(this._target[Symbol.iterator](), inner[Symbol.iterator](), oSelector, iSelector, transform));
    }
    OrderBy(keySelect = selfFn, equal = (a, b) => a - b) {
        return new OrderedLinq(this, (array) => new ArrayIterator(array, 0, (i) => i >= array.length), (a, b) => equal(keySelect(a), keySelect(b)));
    }
    OrderByDescending(keySelect = selfFn, equal = (a, b) => a - b) {
        return new OrderedLinq(this, (array) => new ArrayIterator(array, array.length - 1, (i) => 0 > i, -1), (a, b) => equal(keySelect(a), keySelect(b)));
    }
    ThenBy(keySelect = selfFn, equal = (a, b) => a - b) {
        if (this instanceof OrderedLinq) {
            var superEqual = this.equal;
            this.equal = (a, b) => {
                var result = superEqual(a, b);
                return (0 != result) ? result : equal(keySelect(a), keySelect(b));
            };
            return this;
        }
        else {
            return new OrderedLinq(this, (array) => new ArrayIterator(array, 0, (i) => i >= array.length), (a, b) => equal(keySelect(a), keySelect(b)));
        }
    }
    ThenByDescending(keySelect = selfFn, equal = (a, b) => a - b) {
        if (this instanceof OrderedLinq) {
            var superEqual = this.equal;
            this.equal = (a, b) => {
                var result = superEqual(a, b);
                return (0 != result) ? result : equal(keySelect(a), keySelect(b));
            };
            return this;
        }
        else {
            return new OrderedLinq(this, (array) => new ArrayIterator(array, array.length - 1, (i) => 0 > i, -1), (a, b) => equal(keySelect(a), keySelect(b)));
        }
    }
    Range(start, count) {
        return new Linq(null, () => new GeneratorIterator(start, count, true));
    }
    Repeat(element, count) {
        return new Linq(null, () => new GeneratorIterator(element, count));
    }
    Reverse() {
        var array = Array.isArray(this._target) ? this._target : this.ToArray();
        return new Linq(null, () => new ArrayIterator(array, array.length - 1, (i) => 0 > i, -1));
    }
    Select(transform) {
        return new Linq(this, () => new SelectIteratror(this._target[Symbol.iterator](), transform));
    }
    SelectMany(selector = selfFn, result = selfFn) {
        return new Linq(this, () => new SelectManyIteratror(this._target[Symbol.iterator](), selector, result));
    }
    Skip(skip) {
        var iterator = this._target[Symbol.iterator]();
        for (var i = 0; i < skip; i++)
            iterator.next();
        return new Linq(this, () => new WhereIteratror(iterator, trueFn));
    }
    SkipWhile(predicate = (a, n) => false) {
        return new Linq(this, () => new SkipIterator(this._target[Symbol.iterator](), predicate));
    }
    Take(take) {
        return new Linq(this, () => new TakeIterator(this._target[Symbol.iterator](), (a, n) => take > n));
    }
    TakeWhile(predicate) {
        return new Linq(this, () => new TakeIterator(this._target[Symbol.iterator](), predicate));
    }
    Union(second) {
        var aggregate = [this._target, second];
        return new Linq(this, () => new UnionIteratror(aggregate[Symbol.iterator]()));
    }
    Where(predicate = trueFn) {
        return new Linq(this, () => new WhereIteratror(this._target[Symbol.iterator](), predicate));
    }
    Zip(second, func) {
        return new Linq(this, () => new ZipIteratror(this._target[Symbol.iterator](), second[Symbol.iterator](), func));
    }
}
class OrderedLinq extends Linq {
    constructor(target, factory, equal) {
        super(target, factory);
        this.equal = equal;
    }
    [Symbol.iterator]() {
        if ('undefined' === typeof this._factoryArg) {
            this._factoryArg = this._target.ToArray();
            this._factoryArg.sort(this.equal);
        }
        return this._factory(this._factoryArg);
    }
}
//-----------------------------------------------------------------------------
//  Enumerator implementation
//-----------------------------------------------------------------------------
//  Gets Iterator and turns it into Enumerator 
class Enumerator {
    constructor(sourceIterator) {
        this._iterator = sourceIterator;
    }
    /** Gets the current element in the collection. */
    get Current() {
        return this._result.value;
    }
    /** Advances the enumerator to the next element of the collection.*/
    MoveNext() {
        this._result = this._iterator.next();
        return !this._result.done;
    }
    /** Sets the enumerator to its initial position, which is before the first
    * element in the collection. */
    Reset() {
        throw "JavaScript iterators could not be Reset";
    }
}
//-----------------------------------------------------------------------------
//  Iterators implementation
//-----------------------------------------------------------------------------
class ArrayIterator {
    constructor(_source, _current, _done, _increment = 1) {
        this._source = _source;
        this._current = _current;
        this._done = _done;
        this._increment = _increment;
    }
    next(value) {
        var result = { value: this._source[this._current], done: this._done(this._current) };
        this._current += this._increment;
        return result;
    }
}
class IteratorBase {
    constructor(_iterator) {
        this._iterator = _iterator;
        this._done = { value: undefined, done: true };
    }
}
class DistinctIteratror extends IteratorBase {
    constructor(...args) {
        super(...args);
        this._set = new Set();
    }
    next(value) {
        var result;
        while (!(result = this._iterator.next()).done && this._set.has(result.value)) { }
        this._set.add(result.value);
        return result;
    }
}
class IntersectIteratror extends IteratorBase {
    constructor(iterator, _set, _switch = false) {
        super(iterator);
        this._set = _set;
        this._switch = _switch;
    }
    next(value) {
        var result;
        while (!(result = this._iterator.next()).done && (this._switch == this._set.has(result.value))) { }
        if (!this._switch)
            this._set.add(result.value);
        return result;
    }
}
class GeneratorIterator extends IteratorBase {
    constructor(_current, _count, _increment = false) {
        super(null);
        this._current = _current;
        this._count = _count;
        this._increment = _increment;
    }
    next(value) {
        var result = (0 < this._count) ? { value: this._current, done: 0 >= this._count-- } : this._done;
        if (this._increment)
            this._current++;
        return result;
    }
}
class DefaultIfEmptyIteratror extends IteratorBase {
    constructor(sourceIterator, _default) {
        super(sourceIterator);
        this._default = _default;
    }
    next(value) {
        return this.check(this._iterator.next());
    }
    check(result) {
        if (result.done) {
            result.value = this._default;
        }
        else {
            this.check = (a) => a;
        }
        return result;
    }
}
class MethodIteratror extends IteratorBase {
    constructor(iterator, _method = null, _index = 0) {
        super(iterator);
        this._method = _method;
        this._index = _index;
    }
}
class WhereIteratror extends MethodIteratror {
    next(value) {
        var result;
        do {
            result = this._iterator.next();
        } while (!result.done && !this._method(result.value, this._index++));
        return result;
    }
}
class SkipIterator extends MethodIteratror {
    constructor(...args) {
        super(...args);
        this._hasSkipped = false;
    }
    next(value) {
        var result;
        if (this._hasSkipped)
            return this._iterator.next();
        while (!(result = this._iterator.next()).done && this._method(result.value, this._index++)) { }
        this._hasSkipped = true;
        return result;
    }
}
class TakeIterator extends MethodIteratror {
    next(value) {
        var result = this._iterator.next();
        if (result.done || !this._method(result.value, this._index++)) {
            return this._done;
        }
        return result;
    }
}
class ZipIteratror extends MethodIteratror {
    constructor(first, _second, func) {
        super(first, func);
        this._second = _second;
    }
    next(value) {
        var first = this._iterator.next();
        var second = this._second.next();
        if (first.done || second.done) {
            return this._done;
        }
        return { done: false, value: this._method(first.value, second.value) };
    }
}
class SelectIteratror extends MethodIteratror {
    next(value) {
        var result = this._iterator.next();
        if (result.done)
            return result;
        result.value = this._method(result.value, this._index++);
        return result;
    }
}
class SelectManyIteratror extends MethodIteratror {
    constructor(sourceIterator, selector, transform = selfFn) {
        super(sourceIterator, selector);
        this._collectionState = this._done;
        this._resultState = this._done;
        this._resultSelector = transform;
    }
    next(value) {
        do {
            if (this._resultState.done) {
                this._collectionState = this._iterator.next();
                if (this._collectionState.done)
                    return this._done;
                this._collection = this._method(this._collectionState.value)[Symbol.iterator]();
            }
            this._resultState = this._collection.next();
            if (!this._resultState.done) {
                this._resultState.value = this._resultSelector(this._resultState.value);
            }
        } while (this._resultState.done);
        return this._resultState;
    }
}
class JoinIteratror extends SelectManyIteratror {
    constructor(outer, inner, oKeySelect, iKeySelect, transform) {
        super(outer, null);
        this._method = oKeySelect;
        var result;
        this._map = new Map();
        while (!(result = inner.next()).done) {
            var key = iKeySelect(result.value);
            var group = this._map.get(key);
            if ('undefined' === typeof group) {
                group = [];
                this._map.set(key, group);
            }
            group.push(result.value);
        }
        this._resultSelector = transform;
    }
    /** Gets the next element in the collection. */
    next(value) {
        do {
            if (this._resultState.done) {
                this._collectionState = this._iterator.next();
                if (this._collectionState.done)
                    return this._done;
                var key = this._method(this._collectionState.value);
                var innerSet = this._map.get(key);
                if ('undefined' === typeof innerSet)
                    continue;
                this._collection = innerSet[Symbol.iterator]();
            }
            this._resultState = this._collection.next();
            if (!this._resultState.done) {
                this._resultState.value = this._resultSelector(this._collectionState.value, this._resultState.value);
            }
        } while (this._resultState.done);
        return this._resultState;
    }
}
class UnionIteratror extends SelectManyIteratror {
    constructor(sourceIterator) {
        super(sourceIterator, selfFn);
        this._set = new Set();
    }
    next(value) {
        var result;
        while (!(result = super.next()).done && this._set.has(result.value)) { }
        this._set.add(result.value);
        return result;
    }
}
class GroupByIteratror extends MethodIteratror {
    constructor(iterator, resultSelect, _map) {
        super(iterator, resultSelect);
        this._map = _map;
    }
    next(value) {
        var result = this._iterator.next();
        if (result.done)
            return this._done;
        var iterable = this._map.get(result.value);
        return { value: this._method(result.value, iterable), done: false };
    }
}
class GroupJoinIteratror extends MethodIteratror {
    constructor(iterator, oKeySelect, _transform, _map) {
        super(iterator, oKeySelect);
        this._transform = _transform;
        this._map = _map;
    }
    next(value) {
        var innerSet;
        var result;
        do {
            result = this._iterator.next();
            if (result.done)
                return this._done;
            var key = this._method(result.value);
            innerSet = this._map.get(key);
        } while ('undefined' === typeof innerSet);
        return { value: this._transform(result.value, innerSet), done: false };
    }
}
//-----------------------------------------------------------------------------
// Unility Functions
//-----------------------------------------------------------------------------
/** Default predicate, always true */
var trueFn = () => true;
/** Default transformer, returns self */
var selfFn = o => o;
/** Default Grouping */
var defGrouping = (a, b) => {
    if ('undefined' != typeof b['key'])
        throw "Object already has property [key]";
    b['key'] = a;
    return b;
};
/** Returns default value for the type */
function getDefaultVal(type) {
    if (typeof type !== 'string')
        throw new TypeError('Type must be a string.');
    // Handle simple types (primitives and plain function/object)
    switch (type) {
        case 'boolean': return false;
        case 'function': return function () { };
        case 'null': return null;
        case 'number': return 0;
        case 'object': return {};
        case 'string': return "";
        case 'symbol': return Symbol();
        case 'undefined': return void 0;
    }
    try {
        // Look for constructor in this or current scope
        var ctor = typeof this[type] === 'function'
            ? this[type]
            : eval(type);
        return new ctor;
    }
    catch (e) {
        return {};
    }
}
//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
var nothingFound = "No element satisfies the condition in predicate";
var noElements = "The source sequence is empty.";
var tooMany = "More than one element satisfies the condition in predicate.";
//# sourceMappingURL=linq-ts.js.map